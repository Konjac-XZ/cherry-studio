name: Upstream sync

# Purpose
# - Merge main into bot/upstream-sync (preserves prior conflict resolutions).
# - Merge upstream/main onto bot/upstream-sync (no rebase).
# - Open a squash-only PR from bot/upstream-sync to main so only one commit lands.
# - Skip PR creation when the branch is content-identical to main (avoids "no diff" failures).

on:
  schedule:
    - cron: "0 */4 * * *" # every 4 hours
  workflow_dispatch:

# 1) Prevent overlapping runs (no “jumbled together” behavior)
concurrency:
  group: upstream-sync
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  sync:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: main

      - name: Configure git identity (needed for merge commits)
        run: |
          git config --local user.name "Konjac-XZ"
          git config --local user.email "1951801592@qq.com"

      # 2) Guard / lock: if blocked, do nothing this run
      #    - Blocked if an open conflict issue exists (needs-manual-merge)
      #    - Blocked if an open sync PR already exists (don't keep updating it while you're asleep)
      - name: "Guard: skip if blocked (open conflict issue)"
        id: guard
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Open conflict-lock issue?
            const openIssues = await github.rest.issues.listForRepo({
              owner, repo,
              state: "open",
              labels: "upstream-sync,needs-manual-merge",
              per_page: 1,
            });
            const blockedByIssue = openIssues.data.length > 0;

            // Open upstream-sync PR? Only informational; we still refresh the branch to keep it current.
            const prs = await github.rest.pulls.list({
              owner, repo,
              state: "open",
              head: `${owner}:bot/upstream-sync`,
              base: "main",
              per_page: 1,
            });
            const hasOpenPR = prs.data.length > 0;

            core.setOutput("blocked", blockedByIssue ? "true" : "false");
            core.setOutput("hasOpenPR", hasOpenPR ? "true" : "false");

            if (blockedByIssue) core.notice("Sync is locked by an open merge-conflict issue (needs-manual-merge).");
            if (hasOpenPR) core.notice("An upstream-sync PR is open; branch will be refreshed to current main before updating.");

      - name: Ensure remote-tracking ref for PR branch exists
        if: steps.guard.outputs.blocked != 'true'
        run: |
          git fetch origin bot/upstream-sync:refs/remotes/origin/bot/upstream-sync || true

      - name: Add/fetch upstream
        if: steps.guard.outputs.blocked != 'true'
        run: |
          git remote add upstream https://github.com/CherryHQ/cherry-studio.git || true
          git fetch upstream main --prune

      - name: Check if upstream is ahead
        if: steps.guard.outputs.blocked != 'true'
        id: check
        run: |
          echo "ahead=$(git rev-list --count HEAD..upstream/main)" >> "$GITHUB_OUTPUT"

      # 1) Bring bot/upstream-sync up to date with main (without resetting)
      - name: Merge main into sync branch
        if: steps.guard.outputs.blocked != 'true' && steps.check.outputs.ahead != '0'
        run: |
          git fetch origin main --prune
          if git show-ref --verify --quiet refs/remotes/origin/bot/upstream-sync; then
            git checkout -B bot/upstream-sync origin/bot/upstream-sync
          else
            git checkout -B bot/upstream-sync origin/main
          fi
          git merge --no-edit origin/main

      # 2) Merge upstream/main into bot/upstream-sync (no rebase)
      - name: Merge upstream into sync branch (no rebase)
        if: steps.guard.outputs.blocked != 'true' && steps.check.outputs.ahead != '0'
        id: merge
        shell: bash
        run: |
          set -euo pipefail
          if git merge --no-edit upstream/main; then
            echo "status=clean" >> "$GITHUB_OUTPUT"
          else
            echo "status=conflict" >> "$GITHUB_OUTPUT"
            echo "conflicts<<EOF" >> "$GITHUB_OUTPUT"
            git diff --name-only --diff-filter=U || true
            echo "EOF" >> "$GITHUB_OUTPUT"
            git merge --abort || true
          fi

      - name: Check for tree diff vs main
        if: steps.guard.outputs.blocked != 'true' && steps.check.outputs.ahead != '0' && steps.merge.outputs.status == 'clean'
        id: diff
        run: |
          if git diff --quiet origin/main..HEAD; then
            echo "has_diff=false" >> "$GITHUB_OUTPUT"
            echo "::notice::No tree diff against origin/main; skipping PR creation."
          else
            echo "has_diff=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Push sync branch
        if: steps.guard.outputs.blocked != 'true' && steps.check.outputs.ahead != '0' && steps.merge.outputs.status == 'clean'
        run: |
          git push origin bot/upstream-sync:bot/upstream-sync --force-with-lease

      # 3) Open/refresh PR from bot/upstream-sync -> main; final merge will squash to a single commit
      - name: Ensure PR exists (no rewrite)
        if: steps.guard.outputs.blocked != 'true' && steps.check.outputs.ahead != '0' && steps.merge.outputs.status == 'clean' && steps.diff.outputs.has_diff == 'true'
        id: ensure_pr
        uses: actions/github-script@v7
        env:
          AHEAD: ${{ steps.check.outputs.ahead }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const head = `${owner}:bot/upstream-sync`;
            const base = "main";
            const title = "chore: sync upstream main";
            const body = [
              "Automated upstream sync.",
              `Upstream commits not yet in this repo: ${process.env.AHEAD || "(unknown)"}`
            ].join("\n");

            const prs = await github.rest.pulls.list({ owner, repo, state: "open", head, base, per_page: 1 });
            let prNumber;
            if (prs.data.length > 0) {
              prNumber = prs.data[0].number;
              core.notice(`PR already open: #${prNumber}`);
            } else {
              const pr = await github.rest.pulls.create({ owner, repo, head: "bot/upstream-sync", base, title, body });
              prNumber = pr.data.number;
              core.notice(`Created PR: #${prNumber}`);
            }

            core.setOutput("pull-request-number", prNumber.toString());

      - name: Enable auto-merge (squash)
        if: steps.guard.outputs.blocked != 'true' && steps.check.outputs.ahead != '0' && steps.merge.outputs.status == 'clean' && steps.diff.outputs.has_diff == 'true' && steps.ensure_pr.outputs.pull-request-number != ''
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.ensure_pr.outputs.pull-request-number }}
        with:
          github-token: ${{ secrets.SYNC_PAT }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = Number(process.env.PR_NUMBER);
            if (!prNumber) {
              core.setFailed("Missing pull request number.");
              return;
            }

            const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            if (pr.data.auto_merge) {
              core.notice(`Auto-merge already enabled for #${prNumber}.`);
              return;
            }

            const mutation = `
              mutation($pullRequestId: ID!, $mergeMethod: PullRequestMergeMethod!) {
                enablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId, mergeMethod: $mergeMethod }) {
                  pullRequest {
                    number
                  }
                }
              }
            `;

            await github.graphql(mutation, {
              pullRequestId: pr.data.node_id,
              mergeMethod: "SQUASH",
            });
            core.notice(`Enabled auto-merge (squash) for #${prNumber}.`);

      # 3) Conflict handling: create-or-comment ONE lock issue (no spam),
      #    and future runs will stop due to the guard step.
      - name: Open or update conflict issue (locks future runs)
        if: steps.guard.outputs.blocked != 'true' && steps.check.outputs.ahead != '0' && steps.merge.outputs.status == 'conflict'
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const title = "Upstream sync failed: merge conflicts";
            const runUrl = `${context.serverUrl}/${owner}/${repo}/actions/runs/${context.runId}`;
            const conflicts = `${{ steps.merge.outputs.conflicts }}`.trim() || "(unable to detect files)";
            const mention = "@Konjac-XZ"; // change if needed

            const bodyLines = [
              `${mention} 自动同步 upstream 时出现冲突：我已“加锁”暂停后续自动同步。`,
              "",
              "处理方式：手动解决冲突并更新 bot/upstream-sync（或你自行合并处理），然后关闭此 Issue 或移除 needs-manual-merge 标签以解锁。",
              "",
              "Conflicting files:",
              "```",
              conflicts,
              "```",
              "",
              `Workflow run: ${runUrl}`,
            ].join("\n");

            // Find existing open issue with same title
            const search = await github.rest.search.issuesAndPullRequests({
              q: `repo:${owner}/${repo} is:issue is:open in:title "${title}"`,
              per_page: 1,
            });

            if (search.data.items.length > 0) {
              const issue_number = search.data.items[0].number;
              await github.rest.issues.createComment({ owner, repo, issue_number, body: bodyLines });
            } else {
              await github.rest.issues.create({
                owner, repo,
                title,
                body: bodyLines,
                labels: ["upstream-sync", "needs-manual-merge"]
              });
            }
